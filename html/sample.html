

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rocket Rectangle</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    .flex {
      display: flex;
    }
    .column {
      flex-flow: column wrap;
    }
    .row {
      flex-flow: row wrap;
    }
    .going-center {
      align-items: center;
      justify-content: center;
    }
    .gap {
      gap: 1rem;
    }
    
    body {
      min-height: 100vh;
    }

    button {
      border: black solid 1px;
      color: white;
      cursor: pointer;
      padding: 1rem;
    }

    input {
      background-color: black;
      box-shadow: 0 0 1rem rgb(10, 20, 30);
      border: #222 solid 1px;
      padding: .5rem;
      margin: .5rem;
      outline: none;
      color: aqua;
      font-size: .9rem;
    }

    li {
      margin-left: 1rem;
      font-size: .9rem;
    }

    .std-captured {
      border: transparent solid .1px;
      color: transparent;
      opacity: .1;
    }

    .std-cell {
      background-color: rgb(200, 200, 100);
      padding: .7rem;
      border-radius: .3rem;
    }

    .std-criteria {
      color: yellow;
      font-size: 1.5rem;
    }

    .std-frame {
      height: 4rem;
      width: 5rem;
    }

    .std-key-item {
      font-size: 2rem;
    }

    .std-offset-bottom {
      margin-bottom: 1rem;
    }
    
    .std-offset-top {
      margin-top: 1rem;
    }

    .std-poor-view {
      opacity: .1;
    }

    .std-smooth {
      transition: all linear .5s;
    }

    .std-vanished {
      display: none;
    }

    #controls-area h1, #controls-area h3 {
      background-color: rgb(200, 200, 100);
      border-radius: .5rem;
      padding: 0 2rem;
    }

    #controls-area #tutorial-return-btn-frame #tutorial-return-btn {
      background-color: rgb(200, 200, 100);
      color: black;
    }

    /* #menu-area */
    #menu-area {
      height: 100vh;
    }

    #menu-area #controls-settings, #menu-area #game-settings {
      cursor: pointer;
      font-size: 3rem;
      text-shadow: 0 0 2rem rgb(128, 128, 128);
    }
    
    #menu-area #game-launcher-btn {
      background-color: rgb(0, 50, 100);
    }
    
    #menu-area #game-logo {
      font-size: 10rem;
      transform: rotate(45deg);
      transition: linear all .5s;
    }

    #menu-area #game-title {
      /* color: rgb(200, 200, 100); */
      font-size: 4rem;
      letter-spacing: 3px;
      text-align: center;
      text-shadow: 0 0 2rem rgb(200, 200, 100);
    }

    #settings-area {
      color: white;
      margin: .7rem;
      padding: .5rem;
      text-shadow: 0 0 1rem black;
    }

    #settings-area > * {
      margin-top: 1.5rem;
    }

    #settings-area #background-frame {
      background-color: rgb(33, 66, 99);
      border-radius: .2rem;
      padding: .2rem;
    }

    #settings-area #background-frame #label-background {
      width: 100%;
    }

    #settings-area #background-frame #models #model-a {
      background-image: linear-gradient(15deg, rgb(200, 100, 0), rgb(0, 0, 100), rgb(33, 66, 99));
    }
    #settings-area #background-frame #models #model-b {
      background-image: linear-gradient(15deg, rgb(100, 0, 0), rgb(25, 0, 25), rgb(0, 0, 100));
    }
    #settings-area #background-frame #models #model-c {
      background-image: linear-gradient(15deg, rgb(100, 50, 25), rgb(50, 100, 25), rgb(25, 50, 100));
    }
    #settings-area #background-frame #models #model-d {
      background-image: linear-gradient(15deg, rgb(150, 150, 50), rgb(200, 200, 100), rgb(200, 100, 50));
    }
    #settings-area #background-frame #models #model-e {
      background-image: linear-gradient(15deg, rgb(255, 66, 99), rgb(255, 0, 200), rgb(255, 0, 100));
    }

    #settings-area #custom-background-frame #rgb-inputs-frame #user-custom-background-frame #user-custom-background {
      border-radius: 1rem;
      height: 8rem; 
      width: 8rem; 
    }

    #settings-area #difficulty-frame #levels-frame #easy-btn {
      background-color: green;
    }

    #settings-area #difficulty-frame #levels-frame #medium-btn {
      background-color: orange;
    }

    #settings-area #difficulty-frame #levels-frame #hard-btn {
      background-color: red;
    }

    #settings-area #levels-frame > * {
      color: black;
    }

    #settings-area #save-btn-frame #save-btn {
      background-color: rgb(120, 200, 90);
      position: fixed;
      left: 50%;
      top: 90%;
    }

    #spaceship-area #after-end-game-area {
      background-color: black;
      border: orange solid 1px;
      color: purple;
      padding: 1rem;
      position: fixed;
      top: 1rem;
      left: 1rem;
    }

    #spaceship-area #dexterity-frame #dexterity-bar {
      border-radius: 1rem;;
      background-image: linear-gradient(to top, white 100%);
      box-shadow: 0 0 1rem rgb(33, 66, 99);
      height: 9rem;
      width: 1rem;
    } 

    #spaceship-area #dexterity-frame #dexterity-percentage {
      color: yellow;
      font-size: 2rem;
      font-weight: bold;
      text-align: center;
      position: relative;
      left: 2rem;
      top: 0;
    }

    #spaceship-area #objects-frame #cheat {
      background-color: rgb(33, 66, 99);
      border: white solid 1px;
      border-radius: .4rem;
      box-sizing: border-box;
      color: white;
      font-size: 1.2rem;
      padding: .3rem;
      text-shadow:  0 0 1rem white;
      position: fixed;
      left: 1rem;
      top: 1rem;
    }

    #spaceship-area #objects-frame #give-up-btn {
      background-color: rgb(200, 50, 0);
      border: white solid 1px;
      border-radius: .4rem;
      box-sizing: border-box;
      box-shadow: 0 0 1rem crimson;
      color: white;
      font-size: 1.2rem;
      padding: .3rem;
      text-shadow: 0 0 1rem white;
      position: fixed;
      right: 1rem;
      top: 1rem;
    }
    
    #spaceship-area #objects-frame #clock {
      color: white;
      font-size: 3rem;
      position: fixed;
      bottom: 1rem;
      left: 1rem;
    }

    #spaceship-area #objects-frame #spaceship {
      font-size: 2rem;
      transform: rotate(-45deg);
      transition: all linear .5s;
      text-align: center;
      text-shadow: 0 0 1rem black;
      
      position: relative;
      top: 0;
      left: 0;
      
      border-radius: 70% 0 50% 0;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 2rem;
      width: 2rem;
    }

    #spaceship-area #partial-report-frame #correct, #spaceship-area #partial-report-frame #incorrect {
      color: white;
      font-size: 2rem;
      text-shadow: 0 0 1rem blue;
    }

    #spaceship-area #reboot-btn-frame #reboot-btn {
      background-color: rgb(120, 200, 90);
      box-shadow: 0 0 1rem rgb(110, 210, 100);
    }

    @media (max-width: 1205px) {
      .std-frame {
        height: 3.7rem;
        width: 4.7rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #first-color {
        position: fixed;
        top: 25.5rem;
        left: 18.5rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #second-color {
        position: fixed;
        top: 25.5rem;
        left: 22.5rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #third-color {
        position: fixed;
        top: 25.5rem;
        left: 26.5rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #user-custom-background-frame #user-custom-background {
        position: fixed;
        top: 25.5rem;
        left: 31.5rem;
      }
    }

    @media (max-width: 835px) {
      .std-frame {
        height: 3.3rem;
        width: 3.3rem;
      }
      button {
        padding: .3rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #first-color {
        top: 25rem;
        left: 13.5rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #second-color {
        top: 25rem;
        left: 17.5rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #third-color {
        top: 25rem;
        left: 21.5rem;
      }
    }

    @media (max-width: 700px) {
      #settings-area #custom-background-label-frame #custom-background-label {
        position: fixed;
        top: 20rem;
        left: 8rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #first-color {
        top: 23rem;
        left: 10.5rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #second-color {
        top: 23rem;
        left: 14.5rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #third-color {
        top: 23rem;
        left: 18.5rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #user-custom-background-frame #user-custom-background {
        top: 27rem;
        left: 27rem;
      }
    }

    @media (max-width: 650px) {
      .std-frame {
        height: 2.5rem;
        width: 3.5rem;
      }
      #settings-area #background-frame #models {
        display: flex;
        flex-flow: column wrap;
        width: 40%;
      }
      #settings-area #background-frame {
        margin: 4rem 8rem 0 0;
      }
      #settings-area #levels-frame {
        display: flex;
        flex-flow: column wrap;
        width: 50%;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #first-color {
        top: 23rem;
        left: 7.5rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #second-color {
        top: 23rem;
        left: 11.5rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #third-color {
        top: 23rem;
        left: 15.5rem;
      }
      #settings-area #custom-background-frame #rgb-inputs-frame #user-custom-background-frame #user-custom-background {
        top: 30rem;
        left: 27rem;
      }
    }

    @media (max-width: 600px) {
      #settings-area #custom-background-frame #rgb-inputs-frame #user-custom-background-frame #user-custom-background {
        left: 21.5rem;
      }
    }

  </style>
</head>
<body>
  <main id="main-frame">
    <!---->
    <div id="player-speed-engine-area" class="flex row going-center gap std-vanished std-box">
      <!-- Its value changes as settings are altered -->
      <input type="text" id="speed-input" class="std-vanished" value="0">
    </div>

    <!---->
    <div id="menu-area" class="flex column going-center std-box">
      <div id="game-logo-frame" class="flex column going-center">
        <h2 id="game-title">Rocket Rectangle</h2>
        <p id="game-logo">🚀</p>
      </div>
      
      <div id="game-features-frame" class="flex row going-center">
        <button id="game-launcher-btn">iniciar</button>
        <p id="game-settings">⚙️</p>
        <p id="controls-settings">🎮</p>
      </div>
    </div>
    
    <!---->
    <div id="settings-area" class="flex column going-left std-vanished std-box">
      
      <div id="settings-title-frame" class="flex row going-center">
        <h1 id="settings-title">Configurações</h1>
      </div>

      <div id="difficulty-frame" class="flex row going-left gap">
        <h3 id="label-difficulty">Dificuldade</h3>
        <div id="levels-frame" class="flex row going-center gap">
          <!-- sent to DOM, nothing on style -->
          <button id="easy-btn">fácil</button>
          <button id="medium-btn">médio</button>
          <button id="hard-btn">difícil</button>
        </div>
      </div>

      <div id="background-frame" class="flex row going-left gap">
        <h3 id="label-background">Plano de fundo</h3>
        
        <div id="models" class="flex row going-center gap">
          <p id="model-a" class="std-frame"></p>
          <p id="model-b" class="std-frame"></p>
          <p id="model-c" class="std-frame"></p>
          <p id="model-d" class="std-frame"></p>
          <p id="model-e" class="std-frame"></p>
        </div>
      </div>
      
      <div id="custom-background-label-frame" class="flex row going-left">
        <h3 id="custom-background-label">Seu plano de fundo</h3>
      </div>

      <div id="custom-background-frame" class="flex row going-left gap">
        <div id="rgb-inputs-frame" class="flex row going-center gap">
          <!-- Classes here sento to DOM -->
          <div id="first-color" class="flex column going-center std-smooth">
            <span>direita</span>
            <input class="rgb" id="red-s1" type="text" size="1" placeholder="cor 1" value="0">
            <input class="rgb" id="green-s1" type="text" size="1" placeholder="cor 2" value="0">
            <input class="rgb" id="blue-s1" type="text" size="1" placeholder="cor 3" value="0">
          </div>
          <div id="second-color" class="flex column going-center std-smooth">
            <span>meio</span>
            <input class="rgb" id="red-s2" type="text" size="1" placeholder="cor 1" value="0">
            <input class="rgb" id="green-s2" type="text" size="1" placeholder="cor 2" value="0">
            <input class="rgb" id="blue-s2" type="text" size="1" placeholder="cor 3" value="0">
          </div>
          <div id="third-color" class="flex column going-center std-smooth">
            <span>esquerda</span>
            <input class="rgb" id="red-s3" type="text" size="1" placeholder="cor 1" value="0">
            <input class="rgb" id="green-s3" type="text" size="1" placeholder="cor 2" value="0">
            <input class="rgb" id="blue-s3" type="text" size="1" placeholder="cor 3" value="0">
          </div>
          <!-- Window with the preview of the background -->
          <div id="user-custom-background-frame" class="flex row going-center std-smooth">
            <p id="user-custom-background"></p>
          </div>
        </div>
      </div>
      
      <div id="save-btn-frame" class="flex row going-center">
        <button id=save-btn>salvar</button>
      </div>
      
    </div>
    
    <!---->
    <div id="controls-area" class="flex column going-center std-vanished std-box">
      <h1 id="tutorial-label" class="std-offset-bottom">Tutorial</h1>
      <h3 id="moves-label" class="std-offset-bottom">Movimentos</h3>
      
      <div id="moves-frame" class="flex row going-center gap std-key-item">
        <div class="std-cell">
          <span id="direction-up">⬆️</span>
          <span id="direction-up-key">W</span>
        </div>
        <div class="std-cell">
          <span id="direction-right">➡️</span>
          <span id="direction-right-key">D</span>
        </div>
        <div class="std-cell">
          <span id="direction-down">⬇️</span>
          <span id="direction-down-key">S</span>
        </div>
        <div class="std-cell">
          <span id="direction-left">⬅️</span>
          <span id="direction-left-key">A</span>
        </div>
      </div>

      <div id="goals-frame" class="flex column going-center gap">
        <h3 id="goals-label" class="std-offset-top">Objetivos</h3>
        <div class="std-cell">
          <ul id="goals-steps">
            <li>Usar as teclas p/ movimentar o foguete</li>
            <li><b>Colidir</b> com os adjetivos possessivos</li>
            <li><b>Desviar</b> dos pronomes pessoais</li>
            <li>Ao colidir com adjetivo possessivo: <b>o bloco some</b></li>
            <li>Ao colidir com pronome: <b>foguete gira</b></li>
          </ul>
        </div>
      </div>

      <div id="mechanics-frame" class="flex column going-center gap">
        <h3 id="goals-label" class="std-offset-top">Mecânica</h3>
        <div class="std-cell">
          <ul id="mechanics-steps">
            <li>O jogo realiza um cálculo de performance</li>
            <li>Isso leva em considerações, fatores como:</li>
            <li><b>tempo levado p/ terminar o percurso</b></li>
            <li><b>quantidade de cliques dados</b></li>
            <li><b>quantidade de acertos</b></li>
            <li><b>quantidade de erros</b></li>
          </ul>
        </div>
      </div>

      <div id="tutorial-return-btn-frame" class="flex row going-center std-offset-top">
        <button id="tutorial-return-btn">voltar</button>
      </div>

    </div>

    <!---->
    <div id="spaceship-area" class="flex column going-center std-vanished std-box">

      <div id="after-end-game-area" class="std-vanished">
        <p>tempo de percurso: <span class="std-criteria"></span></p>
        <p>núm. de cliques: <span class="std-criteria"></span></p>
        <p>punição: <span class="std-criteria"></span></p>
      </div>
      
      <div id="dexterity-frame" class="flex row going-center">
        <div id="dexterity-bar" class="std-vanished">
          <p id="dexterity-percentage"></p>
        </div>
      </div>

      <div id="objects-frame" class="flex row going-center gap">
        <span id="cheat">🗣️ | 👽</span>
        <button id="give-up-btn">sair ✋🏻</button>
        <span id="clock">🕰️</span>
        <span id="spaceship">🚀</span>
      </div>

      <div id="partial-report-frame" class="flex column going-center">
        <span id="correct" class="tool"></span>
        <span id="incorrect"></span>
      </div>

      <div id="reboot-btn-frame" class="flex column going-center">
        <button id="reboot-btn" class="std-offset-top std-vanished">recomeçar</button>
      </div>
      
    </div>

    <!---->
    <div id="rectangles-area" class="flex row going-center std-vanished std-poor-view std-box"></div>
  </main>
  <script>

    class StorageObject {
      checkExistance(keyName) {
        return localStorage.getItem(keyName) != null
      }
      configure(keyName, value) {
        localStorage.setItem(keyName, value)
      }
      exhibit(keyName) {
        console.log(this.checkExistance(keyName) ? localStorage.getItem(keyName) : "void") 
      }
      attribute(htmlProperty, storageItem) {
        htmlProperty = storageItem
      }
      // Merge of "checkExistance" & "configure"
      analyse(keyName, value) {
        !this.checkExistance(keyName) ? this.configure(keyName, value) : null
      }
    }

    const backgroundModels = {
      a: "linear-gradient(15deg, rgb(200, 100, 0), rgb(0, 0, 100), rgb(33, 66, 99))",
      b: "linear-gradient(15deg, rgb(100, 0, 0), rgb(25, 0, 25), rgb(0, 0, 100))",
      c: "linear-gradient(15deg, rgb(100, 50, 25), rgb(50, 100, 25), rgb(25, 50, 100))",
      d: "linear-gradient(15deg, rgb(150, 150, 50), rgb(200, 200, 100), rgb(200, 100, 50))",
      e: "linear-gradient(15deg, rgb(255, 66, 99), rgb(255, 0, 200), rgb(255, 0, 100))",
      custom: "linear-gradient(15deg, rgb(200, 100, 0), rgb(0, 0, 100), rgb(33, 66, 99))"
    }

    // Avoid too many "localSotrage.getItem" calls
    const storageInstance = new StorageObject()
    storageInstance.analyse("difficulty-background", "green")
    storageInstance.analyse("game-background", backgroundModels.custom)
    storageInstance.analyse("last-clock", 0)
    storageInstance.analyse("last-number-clicks", 0)
    storageInstance.analyse("player-speed", 60)
    storageInstance.analyse("rect-amount", 30)
    document.body.style.backgroundImage = localStorage.getItem("game-background")
    
    // Everytime page loads (not just by reboot button): reset clicks and clock
    document.addEventListener('DOMContentLoaded', () => {
      storageInstance.configure("last-number-clicks", 0)
      storageInstance.configure("last-clock", 0)
    })

    // Main frame that shelters the entire game
    const mainFrame = document.getElementById("main-frame")

    // Element that determines player's speed
    const speedInput = document.getElementById("speed-input")
    
    // Player
    const spaceship = document.getElementById("spaceship")

    // Miscellania
    const allBackgrounds = [...document.querySelectorAll(".std-frame")]
    const allCustomBackgroundInputs = [...document.querySelectorAll(".rgb")]
    const clock = document.getElementById("clock")
    const userCustomBackground = document.getElementById("user-custom-background")
    const engineCheat = document.getElementById("cheat")
    const dexterityBar = document.getElementById("dexterity-bar")
    const dexterityPercentage = document.getElementById("dexterity-percentage")
    const endGameInfos = [...document.querySelectorAll(".std-criteria")]
    const gameTitle = document.getElementById("game-title")
    
    // Sections
    const afterEndGameArea = document.getElementById("after-end-game-area")
    const controlsArea = document.getElementById("controls-area")
    const menuArea = document.getElementById("menu-area")
    const settingsArea = document.getElementById("settings-area")
    const spaceshipArea = document.getElementById("spaceship-area")
    const rectanglesArea = document.getElementById("rectangles-area")

    // Scores
    const correct = document.getElementById("correct")
    const incorrect = document.getElementById("incorrect")

    // Buttons
    const controlsBtn = document.getElementById("controls-settings") 
    const easyBtn = document.getElementById("easy-btn") 
    const giveUpBtn = document.getElementById("give-up-btn")
    const hardBtn = document.getElementById("hard-btn")
    const launcherBtn = document.getElementById("game-launcher-btn")
    const mediumBtn = document.getElementById("medium-btn") 
    const rebootBtn = document.getElementById("reboot-btn")
    const returnTutorialBtn = document.getElementById("tutorial-return-btn")
    const saveBtn = document.getElementById("save-btn")
    const settingsBtn = document.getElementById("game-settings")
    
    // Arrays
    const buttonsArray = [easyBtn, mediumBtn, hardBtn]
    const colorsArray = ["green", "orange", "red"]
    const tilesAmountArray = [30, 40, 50]
    
    // Backend tools
    const adjectives = ["My", "Your", "His", "Her", "Its", "Our", "Their"]
    const blocksForEasy = []
    const blocksForHard = []
    const blocksForMedium = []
    const captured = []
    const capturedIncorrect = []
    let clockCounter = 0
    const directions = []
    const pronouns = ["I", "You", "He", "She", "It", "We", "They"]

    controlsBtn.addEventListener("click", () => {
      controlWindowsView([menuArea, controlsArea], [0, 1], "std-vanished")
      controlsArea.style.height = "90vh"
    })

    returnTutorialBtn.addEventListener("click", () => {
      controlWindowsView([controlsArea, menuArea], [0, 1], "std-vanished")
    })

    easyBtn.addEventListener("click", () => {
      controlDifficultyTransition(
        0, buttonsArray, colorsArray, tilesAmountArray, 
        "rect-amount", 
        "difficulty-background"
      )
    })

    giveUpBtn.addEventListener("click", () => {
      window.location.reload()
    })

    hardBtn.addEventListener("click", () => {
      controlDifficultyTransition(
        2, buttonsArray, colorsArray, tilesAmountArray, 
        "rect-amount", 
        "difficulty-background"
      )
    })

    launcherBtn.addEventListener("click", () => {
      controlWindowsView([menuArea, spaceshipArea, rectanglesArea], [0, 1, 1], "std-vanished")

      setTimeout(() => {
        rectanglesArea.style.opacity = `${parseFloat(window.getComputedStyle(rectanglesArea).opacity) + getFloat(0.15, 0.34)}`
        setTimeout(() => {
            rectanglesArea.style.opacity = `${parseFloat(window.getComputedStyle(rectanglesArea).opacity) + getFloat(0.15, 0.34)}`
            setTimeout(() => {
              rectanglesArea.style.opacity = `${parseFloat(window.getComputedStyle(rectanglesArea).opacity) + getFloat(0.15, 0.34)}`
              setTimeout(() => {
                rectanglesArea.style.opacity = "1"
                // Only start counting when page is loaded fully
                controlCourseTime(clockCounter, clock, "last-clock")
              }, 500)
            }, 500)
          }, 500)
      }, 500)
      
    })

    mediumBtn.addEventListener("click", () => {
      controlDifficultyTransition(
        1, buttonsArray, colorsArray, tilesAmountArray, 
        "rect-amount", 
        "difficulty-background"
      )
    })

    rebootBtn.addEventListener("click", () => {
      localStorage.setItem("last-number-clicks", 0)
      window.location.reload()
    })

    // Nothing is supposed to be handled here, only update so changes can have effect
    saveBtn.addEventListener("click", () => {
      window.location.reload()
    })

    settingsBtn.addEventListener("click", () => {
      controlWindowsView([menuArea, settingsArea], [0, 1], "std-vanished")
      settingsArea.style.height = "90vh"
      settingsArea.style.width = "50%"
      settingsArea.style.marginLeft = "25%"
    })
    
    const adaptTitleToBackground = (backgroundRef, titleTag) => {
      const newRgb = configureProperRgb(localStorage.getItem(backgroundRef))
      const shades = window.getComputedStyle(titleTag).textShadow.split(" ")
      titleTag.style.color = `rgb(${newRgb.join(", ")})`
      titleTag.style.textShadow = `rgb(${newRgb[2]}, ${newRgb[0]}, ${newRgb[1]}) ${shades[3]} ${shades[4]} ${shades[5]}`
    }
    
    // Pick background choice on settings (only one background visible after "else")
    const controlPickedStandardBackground = (backgroundsQuery, backgroundRef) => {
      let backgroundPos
      
      backgroundsQuery.forEach((tag, pos) => {
        tag.addEventListener("click", () => {
          // Save the position of the background clicked
          backgroundPos = pos
          // Iterate and hide anyone else that was not clicked (to highlight the one clicked)
          for (let i = 0; i < backgroundsQuery.length; i++) {
            if (i != backgroundPos) {
              backgroundsQuery[i].classList.add("std-vanished")
            } else {
              // Highlight and save this background for the next time page loads
              tag.style.border = "orangered solid 2px"
              localStorage.setItem(backgroundRef, window.getComputedStyle(backgroundsQuery[i]).backgroundImage)
            }
          }
        })
      })
    }

    // Loop within is stopped when page is reloaded (any type of loading event)
    const controlCourseTime = (clockVariable, clockTag, clockRef) => {
      const clockLoop = setInterval(() => {
        clockVariable++
        clockTag.textContent = `${clockTag.textContent.split(" ")[0]} ${clockVariable}`
        localStorage.setItem(clockRef, clockVariable)
      }, 1000)
    }

    const controlCustomBackground = (inputsQueryGroup, targetTag, modelsMap, backgroundRefKey) => {
      
      const pallet = [
        {ink: ""},
        {ink: ""},
        {ink: ""},
        {ink: ""},
        {ink: ""},
        {ink: ""},
        {ink: ""},
        {ink: ""},
        {ink: ""}
      ]
      
      const loop = setInterval(() => {
        // Some ways to prevent stupid input values from user
        inputsQueryGroup.forEach((inputTag, pos) => {
          const verificationA = parseInt(inputTag.value) 
          if (verificationA.toString() === "NaN" && inputTag.value != "") {
            inputTag.value = "0"
          }
          else if (inputTag.value.includes(".")) {
            inputTag.value = "0"
          }
          else if (parseInt(inputTag.value) < 0 || (parseInt(inputTag.value) > 255)) {
            inputTag.value = "0"
          }
          else if (inputTag.value[0] === "0" && inputTag.value.length > 1) {
            inputTag.value = "0"
          }
        })
        
        // Put into "pallet" each input value
        inputsQueryGroup.forEach((inputTag, pos) => {
          pallet[pos] = inputTag.value
        })

        let red = "rgb("
        let green = "rgb("
        let blue = "rgb("
        
        for (let i = 0; i < pallet.length; i++) {
          if (i >= 0 && i <= 2) {
            if (i < 2) {
              red += inputsQueryGroup[i].value + ","
            } else {
              red += inputsQueryGroup[i].value
            }
          }
          //
          else if (i > 2 && i <= 5) {
            if (i < 5) {
              green += inputsQueryGroup[i].value + ","
            } else {
              green += inputsQueryGroup[i].value
            }
          } 
          //
          else {
            if (i < inputsQueryGroup.length -1) {
              blue += inputsQueryGroup[i].value + ","
            } else {
              blue += inputsQueryGroup[i].value
            }
            
          }
        }

        red += ")"
        green += ")"
        blue += ")"

        targetTag.style.backgroundImage = `linear-gradient(15deg, ${red}, ${green}, ${blue})`
        
        // Verify if no inputs was changed (they were not touched, standard settings)
        let counter = 0
        for (let i = 0; i < inputsQueryGroup.length; i++) {
          counter += parseInt(inputsQueryGroup[i].value)
        }
        
        // If the model applied by the user is yet not applied: then apply it
        if (modelsMap.custom != window.getComputedStyle(targetTag).backgroundImage && counter != 0) {
          modelsMap.custom = window.getComputedStyle(targetTag).backgroundImage
          localStorage.setItem(backgroundRefKey, modelsMap.custom)
        }
  
      }, 1000)
    }
    
    // Saves last difficulty clicked in the opening of settings
    const controlDifficulty = (levelKeyName, stdValue, levelTagsArray, colorTagsArray) => {
      for (let i = 0; i < colorTagsArray.length; i++) {
        // If what is in local storage matches the color of the button: paint it
        if (localStorage.getItem(levelKeyName) === colorTagsArray[i]) {
          levelTagsArray[i].style.backgroundColor = localStorage.getItem(levelKeyName)
        } 
        // If not: let it with the standard color (to indicate not picked)
        else {
          levelTagsArray[i].style.backgroundColor = stdValue
        }
      }
    }
    
    // When another difficulty is clicked, others become unselected
    const controlDifficultyTransition = (buttonFocusedIndice, buttonsArray, colorsArray, tilesAmountArray, speedRef, levelRef) => {
      for (let i = 0; i < buttonsArray.length; i++) {
        if (i === buttonFocusedIndice) {
          buttonsArray[i].style.backgroundColor = colorsArray[i]
        } else {
          buttonsArray[i].style.backgroundColor = "white"
        }
      }
      localStorage.setItem(speedRef, tilesAmountArray[buttonFocusedIndice])
      localStorage.setItem(levelRef, colorsArray[buttonFocusedIndice])
    } 

    const controlElement = (htmlElement) => {
      const objectOffset = document.addEventListener("keydown", (e) => {
        const offsetStdSpeed = parseInt(localStorage.getItem("player-speed"))
        const currentLeft = parseInt(window.getComputedStyle(htmlElement).left)
        const currentTop = parseInt(window.getComputedStyle(htmlElement).top)
        
        switch (e.key.toLowerCase()) {
          case "a":
            // go left (- values)
            localStorage.setItem("last-number-clicks", parseInt(localStorage.getItem("last-number-clicks")) + 1)
            htmlElement.style.left = `${currentLeft - offsetStdSpeed}px`
            htmlElement.style.transform = `rotate(-135deg)`
            directions.push("l")
            break
          
          case "s":
            // go down (+ values)
            localStorage.setItem("last-number-clicks", parseInt(localStorage.getItem("last-number-clicks")) + 1)
            htmlElement.style.top = `${currentTop + offsetStdSpeed}px`
            if (
              directions[directions.length - 1] === "u" || 
              directions[directions.length - 1] === "r" || 
              directions[directions.length - 1] === "d"
            ) {
              htmlElement.style.transform = "rotate(135deg)"
            } else if (directions[directions.length - 1] === "l") {
              htmlElement.style.transform = "rotate(-225deg)"
            }
            directions.push("d")
            break
          
          case "d":
            // go right (+ values)
            localStorage.setItem("last-number-clicks", parseInt(localStorage.getItem("last-number-clicks")) + 1)
            htmlElement.style.left = `${currentLeft + offsetStdSpeed}px`
            htmlElement.style.transform = "rotate(45deg)"
            directions.push("r")
            break

          case "w":
            // go up (- value)
            localStorage.setItem("last-number-clicks", parseInt(localStorage.getItem("last-number-clicks")) + 1)
            htmlElement.style.top = `${currentTop - offsetStdSpeed}px`
            htmlElement.style.transform = "rotate(-45deg)"
            directions.push("u")
            break
        }
      })

    }

    const controlHintProvider = (htmlHintTag, sourceInfoTag) => {
      const questions = [
        "hi?", "Are you wise?", "I seek knowledge!", "please?", "I thought you were cool!", "Hi there!", "Sup!", "Do you breath?" 
      ]

      const answers = [
        "hello!", "I've got none!", "Who wants to know?", "Nice try!", "None of my business!", "Is this Earth?", "..."
      ]

      const loop = setInterval(() => {
        if (compete(5)) {
          htmlHintTag.textContent = `🗣️ ${questions[getIndice(0, questions.length)]} | 👽 Take this! ${sourceInfoTag[getIndice(0, sourceInfoTag.length)]} 🏆`
        } else {
          htmlHintTag.textContent = `🗣️ ${questions[getIndice(0, questions.length)]} | 👽 ${answers[getIndice(0, answers.length)]}`
        }
      }, 2000)
    }
    
    const controlWindowsView = (tagsGroup, commandsArray, classId) => {
      for (let i = 0; i < tagsGroup.length; i++) {
        if (commandsArray[i]) {
          tagsGroup[i].classList.remove(classId)
        } else {
          tagsGroup[i].classList.add(classId)
        }
      }
    }

    const decreaseOrIncrease = (value, stdValue, outerValue) => {
      return value <= stdValue ? value + outerValue : value - outerValue
    }

    const configureProperRgb = (htmlBackgroundImageValue) => {
      const query = htmlBackgroundImageValue.split("(")[2].split(",").join(" ").split(")")[0].split(" ")
      return [
        decreaseOrIncrease(parseInt(query[0]), 128, getIndice(1, 34)), decreaseOrIncrease(parseInt(query[2]), 128, getIndice(33, 67)), decreaseOrIncrease(parseInt(query[4]), 128, getIndice(66, 100)),
      ]
    }

    const calculatePerformance = (lesserVal, greaterVal) => {
      return parseFloat(100 - ((lesserVal / greaterVal) * 100))
    }

    const getValueSlice = (value, sliceValue) => {
      return value * sliceValue
    }

    const getRounded = (value) => {
      let modular = parseInt(value) - value
      modular = -modular
      return modular >= 0.5 ? parseInt(value) + 1 : parseInt(value) 
    }

    const setupProgressBar = (percentageObtained, progressBarTag, percentageTag, alternativeMsg) => {
      let outset = 0
      
      const loop = setInterval(() => {
        const increased = getIndice(1, 6)
        
        if (outset + increased > percentageObtained) {
          outset += (percentageObtained - outset)
          clearInterval(loop)
        } else {
          outset += increased
        }

        progressBarTag.style.backgroundImage = `linear-gradient(to top, rgb(0, 0, 200) ${outset}%, white ${outset + 1}%)`
        percentageTag.textContent = percentageObtained === 0 ? alternativeMsg : `${outset}%`
        percentageTag.style.fontSize = `${getFloat(1.2, 1.8)}rem`
      }, 100)
    }

    const compete = (chance) => {
      const engineGuess = getIndice(0, 101)
      if (engineGuess > chance) {
        return false
      } else if (engineGuess === chance) {
        compete(chance)
      } else {
        return true
      }
    }

    const getFloat = (tail, head) => {
      return parseFloat((Math.random() * (head - tail) + tail).toFixed(2))
    }

    const getIndice = (tail, head) => {
      return Math.floor(Math.random() * (head - tail) + tail)
    }

    const updateShadows = (htmlElement) => {
      const signal = getIndice(0, 2)
      const score = getIndice(20, 41)
      const elementShadow = window.getComputedStyle(htmlElement).textShadow.split(" ")
      const elementShadowNow = elementShadow[elementShadow.length - 1].split("px")
      htmlElement.style.textShadow = `0 0 ${signal === 0 ? `${parseInt(elementShadowNow) - score}px` : `${parseInt(elementShadowNow) + score}px`} rgb(${elementShadow[0]}, ${elementShadow[1]}, ${elementShadow[2]})`
    }

    const watchForRectangularCollision = (player, target, playerTag) => {
      return player.x < target.x + target.width &&
      player.x + player.width > target.x &&
      player.y < target.y + target.height &&
      player.y + player.height > target.y
    }

    const createTagsSet = (containerTag, amountBlocks) => {
      const newTag = document.createElement("span")
      
      newTag.style.backgroundColor = "rgb(0, 10, 30)"
      newTag.style.boxShadow = "0 0 1rem rgb(0, 10, 30)"
      newTag.style.boxSizing = "border-box"
      newTag.style.color = "rgb(220, 220, 240)"
      newTag.style.position = "relative"
      newTag.style.textAlign = "center"
      
      if (amountBlocks === 30) {
        newTag.style.border = "rgb(0, 100, 0) solid 1px"
        newTag.style.height = "3rem"
        newTag.style.width = "3rem"
        newTag.style.margin = `${getFloat(0.5, 4.1)}rem ${getFloat(0.5, 4.4)}rem ${getFloat(0.5, 4.1)}rem ${getFloat(0.5, 4.4)}rem`
      } else if (amountBlocks === 40) {
        newTag.style.border = "orange solid 1px"
        newTag.style.height = "2.2rem"
        newTag.style.width = "2.2rem"
        newTag.style.margin = `${getFloat(0.7, 3.8)}rem ${getFloat(0.7, 4.4)}rem ${getFloat(0.7, 3.8)}rem ${getIndice(0.7, 4.4)}rem`
      } else {
        newTag.style.border = "rgb(200, 0, 0) solid 1px"
        newTag.style.height = "2rem"
        newTag.style.width = "2rem"
        newTag.style.margin = `${getFloat(0.9, 3.5)}rem ${getFloat(0.9, 4.0)}rem ${getFloat(0.9, 3.5)}rem ${getFloat(0.9, 4.0)}rem`
        newTag.style.fontSize = ".8rem"
      }
      
      newTag.setAttribute("class", "box flex row going-center")
      containerTag.appendChild(newTag)
    }

    const createContentForBlocks = (levelRef, blocksRef, blocksQuery, levelArray, incorrectDataArray, correctDataArray) => {
      
      let blocksToBeCreated = 0
      const difficulty = localStorage.getItem(levelRef)
      
      while (blocksToBeCreated < 10) {
        const pos = getIndice(0, parseInt(localStorage.getItem(blocksRef)) - 5)
        
        if (!levelArray.includes(pos)) {
          levelArray.push(pos)
          blocksToBeCreated++
        }
      }

      let i = 0
      while (i < 10) {
        blocksQuery[levelArray[i]].textContent = correctDataArray[getIndice(0, correctDataArray.length)]
        i++
      }
      blocksQuery.forEach((tag, pos) => {
        tag.textContent === "" ? tag.textContent = incorrectDataArray[getIndice(0, incorrectDataArray.length)] : null
      })
      
    }

    const animateLogo = (logoTag) => {
      const loop = setInterval(() => {
        logoTag.style.transform = `rotate(${45 + getIndice(-50, 51)}deg)`
      }, 500)
    }

    adaptTitleToBackground("game-background", gameTitle)
    animateLogo(document.getElementById("game-logo"))
    controlDifficulty("difficulty-background", "white", buttonsArray, colorsArray)
    controlElement(spaceship)
    controlHintProvider(engineCheat, adjectives)
    controlPickedStandardBackground(allBackgrounds, "game-background")

    let playerOffsetSpeed = 0
    let numberBlocks = parseInt(localStorage.getItem("rect-amount"))
    
    // There were problems with the amount of blocks, so it takes the total - 5
    for (let i = 0; i < numberBlocks - 5; i++) {
      createTagsSet(rectanglesArea, numberBlocks)
      if (i === 0) {
        if (numberBlocks === 30) {
          playerOffsetSpeed = 60
        } else if (numberBlocks === 40) {
          playerOffsetSpeed = 55
        } else {
          playerOffsetSpeed = 50
        }
      }

      // Apply player's standard speed only once during indice 0
      if (i === 0) {
        speedInput.value = playerOffsetSpeed
        localStorage.setItem("player-speed", playerOffsetSpeed)
      }
    }
    
    const allRectangles = [...document.querySelectorAll(".box")]

    createContentForBlocks("difficulty-background", "rect-amount", allRectangles, blocksForEasy, pronouns, adjectives)

    controlCustomBackground(allCustomBackgroundInputs, userCustomBackground, backgroundModels, "game-background")

    const loop = setInterval(() => {
      launcherBtn.textContent = correct.textContent === "0" ? "Iniciar" : "Continuar..."
      correct.textContent = captured.length - capturedIncorrect.length
      const spaceshipStats = spaceship.getBoundingClientRect()
      updateShadows(spaceship)
      
      allRectangles.forEach(rect => {
        const rectStats = rect.getBoundingClientRect()
        const rectangleCollision = watchForRectangularCollision(spaceshipStats, rectStats, spaceship)
        
        // When collision happens in the right place
        if (rectangleCollision && adjectives.includes(rect.textContent)) {
          if (!captured.includes(rect)) {
            rect.classList.add("std-captured")
            rect.style.color = "transparent"
            captured.push(rect)
          }
        }
        
        // When not
        if (rectangleCollision && !adjectives.includes(rect.textContent)) {
          spaceship.style.transform = "rotate(1000deg)"
          if (!capturedIncorrect.includes(rect)) {
            capturedIncorrect.push(rect)
          }
        }
        
        // End game when max score reached
        if (captured.length === 10) {

          // Get clicks report and include it into the dexterity calculus
          const totalClicks = parseInt(localStorage.getItem("last-number-clicks"))
          const totalClicksSlice = getValueSlice(totalClicks, 0.15)
          const clicksInfluenceValue = getRounded(totalClicksSlice / 1.5)

          // Starting resources to calculate performance/dexterity (final ones below)
          const completionTime = parseInt(localStorage.getItem("last-clock"))
          const completionTimeSliceValue = getValueSlice(completionTime, 0.15)
          const roundedCompletionTimeSliceValue = getRounded(completionTimeSliceValue)

          // Avoids too many "classList" calls in columns
          controlWindowsView([engineCheat, giveUpBtn, dexterityBar, rebootBtn, rectanglesArea], [0, 0, 1, 1, 0], "std-vanished")
          
          // Highlight result area
          spaceshipArea.style.height = "100vh"
          
          // Dexterity procedures
          let lesserValue = captured.length < capturedIncorrect.length ? captured.length : capturedIncorrect.length
          let greaterValue = captured.length < capturedIncorrect.length ? capturedIncorrect.length : captured.length
          
          // For negative scores
          if (greaterValue > 10) {
            lesserValue = greaterValue - lesserValue
            greaterValue = 10
          }
          
          // Drawing has 50%, others are calculated in the standard way
          const thisTurnDexterity = lesserValue === greaterValue 
          ? 50 
          : calculatePerformance(lesserValue, greaterValue)

          // Final steps to dexterity calculus and hide clock
          const discount = getRounded(thisTurnDexterity / roundedCompletionTimeSliceValue)
          const shapedPerformance = thisTurnDexterity - discount
          const bonus = getRounded(calculatePerformance(completionTime, shapedPerformance))
          let realPerformance = completionTime <= 70 
          ? getRounded(completionTime + bonus) - clicksInfluenceValue
          : getRounded((completionTime / 2) - bonus) - clicksInfluenceValue

          // When there were more mistakes then right answers
          if (lesserValue > 0) {
            const slice = realPerformance - parseInt(realPerformance / 1.2)
            realPerformance -= slice
          }
          
          const difficulty = localStorage.getItem("difficulty-background")
          if (difficulty === "green" && lesserValue <= 0) {
            if (completionTime <= 20) {
              realPerformance += 7
            } else if (completionTime <= 30) {
              realPerformance += 3
            }
          } else if (difficulty === "orange" && lesserValue <= 0) {
            if (completionTime <= 45) {
              realPerformance += 7
            } else if (completionTime <= 55) {
              realPerformance += 3
            }
          } else if (difficulty === "red" && lesserValue <= 0) {
            if (completionTime <= 60) {
              realPerformance += 7
            } else if (completionTime <= 66) {
              realPerformance += 3
            }
          }
          
          clock.classList.add("std-vanished")
          
          correct.textContent = `acertos: ${captured.length}`
          incorrect.textContent = `erros: ${capturedIncorrect.length}`

          // console.log("--o ", [completionTime, bonus, totalClicks, clicksInfluenceValue])
          
          // It seems this function only works if the origin loop is ceased, other wise, there will be lots of issues 
          realPerformance <= 0 
          ? setupProgressBar(0, dexterityBar, dexterityPercentage, "desclassificado!")
          : setupProgressBar(realPerformance, dexterityBar, dexterityPercentage, "")
          
          afterEndGameArea.classList.remove("std-vanished")
          
          const stats = [`${completionTime} seg`, `${totalClicks}`, `${clicksInfluenceValue}%`]
          
          endGameInfos.forEach((tag, pos) => {
            realPerformance <= 0 ? tag.textContent = `🚫` : tag.textContent = stats[pos]
          })
          
          clearInterval(loop)
          
        }
      })
    }, 1)
    
  </script>

</body>
</html>
